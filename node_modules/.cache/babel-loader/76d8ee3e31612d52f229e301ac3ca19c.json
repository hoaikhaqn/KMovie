{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"../utils\");\n\nfunction applyGroupByLocally(documents, astGroupBy) {\n  utils_1.assert(astGroupBy.length > 0, 'GROUP BY needs at least 1 group.');\n  var group = new DocumentsGroup();\n  group.documents = documents;\n  astGroupBy.forEach(function (groupBy) {\n    utils_1.assert(groupBy.type === 'column_ref', 'GROUP BY only supports grouping by field names.');\n    group = applySingleGroupBy(group, groupBy);\n  });\n  return group;\n}\n\nexports.applyGroupByLocally = applyGroupByLocally;\n\nfunction applySingleGroupBy(documents, groupBy) {\n  var groupedDocs = {};\n\n  if (documents instanceof DocumentsGroup) {\n    // We just have a list of documents\n    var numDocs = documents.documents.length;\n\n    for (var i = 0; i < numDocs; i++) {\n      var doc = documents.documents[i]; // Since we're going to use the value as an object key, always\n      // coherce it to a string in case it's some other type.\n\n      var groupValue = String(utils_1.safeGet(doc, groupBy.column));\n\n      if (!utils_1.contains(groupedDocs, groupValue)) {\n        groupedDocs[groupValue] = new DocumentsGroup();\n      }\n\n      groupedDocs[groupValue].documents.push(doc);\n    }\n\n    return groupedDocs;\n  } else {\n    // We have documents that have already been grouped with another field\n    var currentGroups = Object.keys(documents);\n    currentGroups.forEach(function (group) {\n      groupedDocs[group] = applySingleGroupBy(documents[group], groupBy);\n    });\n    return groupedDocs;\n  }\n}\n\nvar DocumentsGroup =\n/** @class */\nfunction () {\n  function DocumentsGroup(key) {\n    this.key = key;\n    this.documents = [];\n    this.aggr = {\n      sum: {},\n      avg: {},\n      min: {},\n      max: {},\n      total: {}\n    };\n  }\n\n  return DocumentsGroup;\n}();\n\nexports.DocumentsGroup = DocumentsGroup;","map":null,"metadata":{},"sourceType":"script"}